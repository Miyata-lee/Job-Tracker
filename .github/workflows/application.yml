name: Deploy Application
on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: jobtracker
  ENVIRONMENT: dev
  ASG_NAME: jobtracker-asg-dev
  LB_NAME: jobtracker-alb-dev
  TG_NAME: jobtracker-tg-dev
  APP_PORT: 5000
  HEALTH_PATH: /health

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::107411014674:role/github-jobtracker-role
          role-session-name: jobtracker-app-deploy
          audience: sts.amazonaws.com

      - name: Prep SSH key
        run: |
          install -m 600 /dev/null ~/.ssh/key.pem
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/key.pem


      - name: Get InService EC2 instance IDs
        id: asg
        run: |
          IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "${ASG_NAME}" \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)
          echo "ids=$IDS" >> $GITHUB_OUTPUT

      - name: Get public IPs
        id: ips
        run: |
          if [ -z "${{ steps.asg.outputs.ids }}" ]; then
            echo "No InService instances"
            exit 1
          fi
          EC2_IPS=$(aws ec2 describe-instances --instance-ids ${{ steps.asg.outputs.ids }} \
            --query 'Reservations[].Instances[?PublicIpAddress!=null].PublicIpAddress' --output text)
          echo "$EC2_IPS" | tr '\t' '\n' > /tmp/ec2_ips.txt
          cat /tmp/ec2_ips.txt

      - name: Copy scripts to EC2
        run: |
          for ip in $(cat /tmp/ec2_ips.txt); do
            scp -i ~/.ssh/key.pem -o StrictHostKeyChecking=no scripts/deploy-rds.sh scripts/deploy-ec2.sh ec2-user@$ip:/home/ec2-user/
          done

      - name: Run RDS schema on EC2
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ env.DB_NAME }}
        run: |
          for ip in $(cat /tmp/ec2_ips.txt); do
            ssh -i ~/.ssh/key.pem -o StrictHostKeyChecking=no ec2-user@$ip \
              "export DB_HOST='${DB_HOST}' DB_USER='${DB_USER}' DB_PASSWORD='${DB_PASSWORD}' DB_NAME='${DB_NAME}'; bash ~/deploy-rds.sh"
          done

      - name: Deploy App on EC2 (systemd on 5000)
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ env.DB_NAME }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          CORS_ORIGINS: "*"
        run: |
          for ip in $(cat /tmp/ec2_ips.txt); do
            ssh -i ~/.ssh/key.pem -o StrictHostKeyChecking=no ec2-user@$ip \
              "export DB_HOST='${DB_HOST}' DB_USER='${DB_USER}' DB_PASSWORD='${DB_PASSWORD}' DB_NAME='${DB_NAME}' SECRET_KEY='${SECRET_KEY}' CORS_ORIGINS='${CORS_ORIGINS}'; bash ~/deploy-ec2.sh"
          done

      - name: Verify local health on each instance
        run: |
          for ip in $(cat /tmp/ec2_ips.txt); do
            ssh -i ~/.ssh/key.pem -o StrictHostKeyChecking=no ec2-user@$ip \
              "curl -fsS --connect-timeout 2 --max-time 3 http://127.0.0.1:${APP_PORT}${HEALTH_PATH}" >/dev/null
          done

      - name: Deploy Frontend to S3
        env:
          PROJECT_NAME: ${{ env.PROJECT_NAME }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          AWS_REGION: ${{ env.AWS_REGION }}
          CF_ALIAS_MATCH: ${{ secrets.CF_ALIAS_MATCH }} # optional
        run: FRONTEND_DIR=application/frontend-app/templates bash scripts/deploy-frontend.sh

      - name: Check Target Group health (HTTP:5000 /health)
        run: |
          TG_ARN=$(aws elbv2 describe-target-groups --names "${TG_NAME}" \
            --query 'TargetGroups[0].TargetGroupArn' --output text)
          aws elbv2 describe-target-groups --names "${TG_NAME}" \
            --query 'TargetGroups[0].[Port,HealthCheckPort,HealthCheckPath,Matcher.HttpCode]' --output table
          for i in {1..60}; do
            STATES=$(aws elbv2 describe-target-health --target-group-arn "$TG_ARN" \
              --query 'TargetHealthDescriptions[*].TargetHealth.State' --output text || true)
            echo "States: $STATES"
            if [ -n "$STATES" ] && ! grep -qv '^healthy$' <<< "$STATES"; then
              echo "All targets healthy"
              exit 0
            fi
            sleep 5
          done
          echo "Targets not healthy in time"
          exit 1

      - name: ALB /health
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers --names "${LB_NAME}" \
            --query 'LoadBalancers[0].DNSName' --output text)
          echo "Checking http://${ALB_DNS}${HEALTH_PATH}"
          curl -fsS --connect-timeout 2 --max-time 3 "http://${ALB_DNS}${HEALTH_PATH}" >/dev/null
